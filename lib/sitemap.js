'use strict';

var ___ = require('lodash'),
    builder = require('xmlbuilder'),
    chalk = require('chalk'),
    fs = require('fs'),
    Q = require('q'),
    utils = require('./utils'),
    xml2js = require('xml2js');


var sitemapFile = 'sitemap.xml';

/**
 * Recursive function that compares immutable properties on two objects.
 * @private
 * @param {Object} a Source object that will be compared against
 * @param {Object} b Comparison object. The functions determines if all of this object's properties are the same on the first object.
 * @return {Boolean} Returns true if all of the properties on `b` matched a property on `a`. If not, it returns false.
 */
function compare(a, b) {
    for (var key in a) {
        if (a.hasOwnProperty(key)) {

            if (typeof a[key] !== typeof b[key]) {
                return false;
            }

            if (typeof a[key] === "object") {
                if (!compare(a[key], b[key])) {
                    return false;
                }
            } else if (a[key] !== b[key]) {
                return false;
            }
        }
    }

    return true;
}

/**
 * Recursive function that takes two objects and updates the properties on the
 * first object based on the ones in the second. Basically, it's a recursive
 * version of Object.assign.
 */
function deepAssign(object, source) {
    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            if (typeof object[key] === 'object' && typeof source[key] === 'object') {
                deepAssign(object[key], source[key]);
            } else {
                object[key] = source[key];
            }
        }
    }

    return object;
}


function getSitemap(ignoreENOENT) {

    utils.log.verbose('Returning local ' + sitemapFile + ' in JSON format. \n');

    var deferred = Q.defer(),
        pages = [],
        parser = new xml2js.Parser();


    fs.readFile(sitemapFile, function(err, sitemapData) {

        if (err) {
            // file doesn't exist
            if( err.errno === -2 && ignoreENOENT){
                deferred.resolve(false);
            }
            else{
               utils.q.throwError(deferred, err);
            }
        }

        parser.parseString(sitemapData, function(err, result) {

            if (err) {
                utils.q.throwError(deferred, err);
            } else if (result.urlset && Array.isArray(result.urlset.url)) {

                pages = result.urlset.url.map(function(item) {
                    return item.loc[0];
                });

                deferred.resolve(pages);
            }
        });
    });

    return deferred.promise;
}


/**
 * Write the XML file.
 *
 * @param  {Function} callback Callback function to execute
 */
function writeSitemapXML(crawledLinks, callback) {

    var ignoreENOENT = true,
        sitemap,
        xml = builder.create('urlset', { version: '1.0', encoding: 'UTF-8' })
        .commentAfter('XML Sitemap generated by devopsgroup.io/Siteshooter')
        .att('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance')
        .att('xmlns:image', 'http://www.google.com/schemas/sitemap-image/1.1')
        .att('xsi:schemaLocation', 'http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd')
        .att('xmlns', 'http://www.sitemaps.org/schemas/sitemap/0.9');



    return getSitemap(ignoreENOENT).then(function(sitemapData) {

        // sitemap.xml file exist?
        if( sitemapData ){

            // If sitemap.xml file links match crawled links, no need to re-create sitemap.xml file
            if( compare(crawledLinks, sitemapData) ){

                return callback(null, sitemapFile);
            }
            else{

                // append new link(s) to the bottom of the file
                deepAssign(crawledLinks, sitemapData);
            }
        }

        ___.forIn(crawledLinks, function(url) {
            xml.ele('url')
                .ele({
                loc: url,
                changefreq: 'weekly'
            });
        });

        sitemap = xml.end({ pretty: true, indent: '  ', newline: '\n' });

        fs.writeFile(sitemapFile, sitemap, function(err) {
            if (typeof callback === 'function') {
                return callback(err, sitemapFile);
            }
            return err;
        });

    }).catch(function(error) {
        return callback(error, sitemapFile);
    });
}


/**
 * Delete local sitemap.xml file
 * @author Steven Britton
 * @date   2016-04-12
 * @return {[type]}   [description]
 */
function sitemapDelete() {

    var deferred = Q.defer();

    function deleteFile(sitemap, callback) {
        fs.unlink(sitemap, function(err) {

            if (typeof callback === 'function') {
                return callback(err, sitemap);
            }
            return err;
        });
    }

    deleteFile(sitemapFile, function(err, sitemap) {
        if (err) {
            utils.q.throwError(deferred, err);
        } else {
            utils.log.log(chalk.green.bold('✔︎ '), chalk.yellow(sitemap, ' was successfully deleted.'));
            deferred.resolve();
        }
    });

    return deferred.promise;

}


module.exports ={
    get: getSitemap,
    delete: sitemapDelete,
    writeXML: writeSitemapXML
};
